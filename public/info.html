<!DOCTYPE html>
<html lang="en">
    <head>
        <meta http-equiv="content-type" content="text/html; charset=UTF-8"> 
        <title>TeamPlayer - Product Wiki</title>
        <meta name="generator" content="Bootply" />
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
        <link href="css/bootstrap.min.css" rel="stylesheet">
        
        <!--[if lt IE 9]>
          <script src="//html5shim.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->

        <!-- CSS code from Bootply.com editor -->
        
        <style type="text/css">
            header {
	margin-bottom:30px;
}

        </style>
    </head>
    
    <!-- HTML code from Bootply.com editor -->
    
    <body  >
        
        
<header class="navbar navbar-default navbar-static-top" role="banner">
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".navbar-collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a href="development.html" class="navbar-brand">TeamPlayer</a>
    </div>
    <nav class="collapse navbar-collapse" role="navigation">
      <ul class="nav navbar-nav">
        <li>
          <a href="wiki.html">Information</a>
        </li>
        <li>
          <a href="getstarted.html">Getting Started</a>
        </li>
        <li>
          <a href="usersdoc.html">User Documentation</a>
        </li>
        <li>
          <a href="srssds.html">Specifications</a>
        </li>
        <li>
          <a href="devteam.html">Developers</a>
        </li>
        <li>
          <a href="contact.html">Contact</a>
        </li>
      </ul>
    </nav>
  </div>
</header>

<!-- Begin Body -->
<div class="container">
	<div class="row">
  			<div class="col-md-3" id="leftCol">
              	
				<div class="well"> 
              	<ul class="nav nav-stacked" id="sidebar">
                  <li><a href="#designChoices">Design Choices</a></li>
                  <li><a href="#riskAssess">Risks Assessment</a></li>
                  <li><a href="#testPlans">Test Plans</a></li>
                  <li><a href="#codingStyle">Coding Style Guidelines</a></li>
                  <li><a href="#changeLogSDS">Change Log</a></li>
              	</ul>
  				</div>

      		</div>  
      		<div class="col-md-9">
                <p><i>This page acts as our living Software Design Specifications</i></p>
                <hr>


                <h2 id="designChoices">Design Choices</h2>
              	<p>A major design decision was around Ruby on Rails. We had to decide between using the full power of Rails—frontend to backend, or, a mix of Rails (backend) and AngularJS on the frontend. We eventually decided on the mixed method because AngularJS has many features that simplify our UI implementation. Here are the main pros and cons of our chosen method:
                </p>
                <h4>Pros:</h4>
	              <ul>
                 <li> We can better split up the frontend/backend groups, so each can work independently without worrying about the implementation of the other group. This would have been possible in Rails, but we decided it would be easier this way.
                 </li>
                 <li>AngularJS allows us to have a MVC on the client side—so as the model updates, the view will instantly be updated.</li>
                 <li>We still could have used Angular even with using all of Rails, but it would limit the functionality that we could have used from Angular.</li>
                 <li>Doing a lot more work on the frontend is better because more of us know JavaScript than Ruby. Either way, we felt JavaScript and Angular would be *much* easier to learn than Ruby and Rails.</li> 
                </ul>

                <h4>Cons:</h4>
                <ul>
                  <li> We have two frameworks to learn rather than just one. Since all team members but me (Karthik) are only dealing with frontend *or* backend, they probably would only need to worry about learning one. I would need to learn both because I am connecting the two.</li>
                  <li> We probably increase the amount of code we have to write, because we now have two sets of models—the databases Events, Users, and Groups, and the parallel AngularJS models. We also have two sets of controllers for Events, Users, and Groups. This will not have a lot of redundant code, because they have very different responsibilities, but it will make the system larger than it would have been otherwise. </li>
                </ul>

              	<hr>

<p>Another design decision where we considered an alternative was with our todo’s vs tasks. We spent a long time trying to figure out how we were going to implement these, and were seriously considering not implementing them as an option. It came down to whether or not we believed it was a serious need for people when creating a task and if we thought people would actually use it. We brainstormed tasks that we might put on our app, like taking out the trash or buying milk. We decided that these really didn’t need a date, and would be useful to create a new type of task for these. 
                </p>
                <h4>Pros:</h4>
                <ul>
                 <li> They would be much simpler for the user, you just check it off when you finish and then it becomes someone else’s turn. We could see this being useful so that people don’t have to worry about dates, and just handle the task when needed. 
                 </li>
                </ul>

                <h4>Cons:</h4>
                <ul>
                  <li>It adds a new option to tasks that can be confusing, and we weren’t sure how to fit into the UI both in creating tasks and in the home page.</li>

                </ul>



                <hr>
                <h2 id="riskAssess">Risk Assessment</h2>
                1. <i>Keeping up with our schedule and finish all our core features in time</i>
                <p><ul>This risk has a medium likelihood of occurring. Scheduling and timing is going to be an issue in any project but I feel like we have split our project up well and done a good job providing ourselves with a reasonable schedule. So if we stick to that we can greatly reduce the risk. The impact would be very high if it occurred, as falling behind schedule pushes everything else back, which can have a landslide effect and cause us to either have to cut features or not finish in time. We based our schedule on past experiences creating a web page and how complex we think each part will be. It will be easier to estimate after we have some actual code finished. Then we can adjust our schedule if needed to better estimate our time, which will help reduce the risk of falling behind schedule.</ul></p>

                2. <i>Keeping backend synched with frontend</i>
                <p><ul>The risk of here is not being able to synch the backend and frontend. That can either happen if we are not working on the same parts at the same time, or if the code is written in a way that we can’t connect the two. The risk of this happening is low because while we don’t always meet as a whole group, but at the same time we have a schedule we are all following so we should all be on the same page. And Karthik meets with both to make sure that everything is connected and going according to plan. If it does happen though, the impact will be quite high as we may have to go back and redo our code to integrate the parts because our app won’t work if the two parts don’t connect right. So to reduce the risk, we are making sure we have good team communication through weekly team meetings, talking through facebook and email, and Karthik checking both sides.</ul></p>


                3. <i>Keep UI simple and useable, but still functional</i>
                <p><ul>The risk is that we might go too far in one direction. We can potentially make the UI way too simple and not having enough functionality for users to use our application to manage their group easily. We also might make the application way too complex, during planning we often have new ideas, new features we could add, so we have to pay attention to the feature creep problem. We need to have a good balance between the two, and could be difficult. Especially because we are biased because this is our product, it is easy for us to think a UI is simple to use when it actually isn’t. The impact of this is medium, because the app will still have all of its features available, but it will just look different confusing and uninviting. Depending on how simple or how complex it is, it can push some users away from using our app. To try and reduce this risk, it is important for us to keep having customer meetings because that is a great way to get an outside opinion on our UI. Once we have a working UI, we can also use hallway usability tests to see what new users think of our UI. </ul></p>

                4.<i> Have everyone work close enough to help each other, but on separate tasks for efficiency</i>
                <p><ul>The risk is that we may not balance between the two well. For instance, if we always work together as a group, where all seven of us are sitting together, we might not get as much done because we will end up all working on the same part of our product. On the other hand, if we always work individually and just merge everyone’s work, we might not be able to understand each other’s work and merging becomes difficult. If we don’t understand other’s work, it is impossible to understand the product as a whole. It also increase the difficulty of debugging other’s code. The likelihood of this occurring is low, as we have separated into smaller groups to do group work, and also assign task for everyone to work on individually. On the other hand, we also have regular group meeting for everyone to communicate with the whole group. In other words, we have been using an approach that deals with this problem. The impact of this risk is medium, especially later in the development process since as the project grow, it is harder to understand what other did in the past. To detect this, we will have weekly meetings where everyone will talk briefly about what they think others have done. If someone is clearly not understanding the group progress, we need to get everyone up to date by showing each other what we have done. Also, we need to adjust our meetings to make communication more clear and efficient. </ul></p>


                5. <i>Create variety of options for events to be simple but fit all needs of user</i>
                <p><ul>This is a pretty big risk for us because we are trying to add enough features to meet the needs of our users, such as tasks or bills that may not always have a date. Or repeating/cycle tasks like taking out the trash or getting milk which may not always have a set date. But depending on how we implement these features, it can be extremely cluttered and difficult for the user to use. The create event feature would be extremely complex with too many options and unfriendly to users. So the impact is high because this is one of our most important features that differentiates our app from other similar ones. So we need to add these features in a way that is easy to use and understandable to the user, but also helpful. To reduce the risk here we need to do a lot of user testing through customer meetings and hallway usability tests specifically for this portion of our app.</ul></p> 
                <br><br>
                <p>Our risks are pretty similar to the risks we had from the SRS, except now we have some more specific risks because we know more about our app. Timing and integration between frontend and backend are always going to be risks that can have a huge impact on the project throughout the whole entire process. But now that we have spent more time working on the UI and making design decisions according to feedback from customers, we better understand what will be difficult and is a high risk for the project. We know that the events cycling will be difficult, but necessary, and also understand that creating a simple, usable UI that is pleasing to users is difficult.</p>

              	<hr>
              

                <h2 id="testPlans">Test Plans</h2>
                <ul>
                  <li><h4>Unit Test Strategy</h4>
                    <ul>
                      <li>The unit tests will test most (not all as small private functions may be tested as part of other functions) functions in a black box and glass box way.</li>
                      <li>Ruby on Rails provides an integrated unit testing system so making tests will not be very complicated, the tests will be written by the developer of the function. We will not write major functions without testing them thoroughly. Here is a good reference tutorial and style guide to follow: http://guides.rubyonrails.org/testing.html for the specifics of how we would unit test controllers in Ruby.</li>
                      <li>AngularJS (frontend) also provides a unit testing system. It is a little more complicated because it deals with simulating certain events, but we plan to follow a similar strategy. The major controller functions and model functions will be tested in parallel with developing them. Here is a good reference tutorial we will use: https://docs.angularjs.org/guide/unit-testing for the specifics on how testing works in Angular.</li>
                      <li>We plan to create test usually while developing a class so testing should be done once a function is done. We will require that before pushing code to the master branch, all of their test code must pass and seen by at least one team member. No automation system seems necessary at the moment--we can just run the tests before pushing. </li>
                      <li>In general, we may not have the backend implemented at the same time as the frontend (and vice versa), so we will likely hardcode dummy JSON objects on both ends to use for testing, and actually connect them during system testing. </li>
                    </ul>
                  </li>
                  <li><h4>System Test Strategy</h4>
                    <ul>
                      <li>The system test will test the integration of composite classes and the connection between the backend and frontend. While unit tests on each end used dummy JSON values, now we will actually allow the frontend and backend to communicate over the wire. These tests will mainly check that this communication works correctly. </li>
                      <li>We will mainly do systems testing on the frontend. We can use similar (or even the same) tests from the unit tests, and now ensure that sending/receiving data on the frontend and backend work correctly.</li>
                      <li>We will do system tests after every major component (e.g. viewing and creating events) is done both on the frontend and backend. Again, we are not going to use automation testing. </li>
                    </ul>
                  </li>
                  <li><h4>Usability Test Strategy</h4>
                  <ul>
                    <li>We will mainly focus on hallway usability testing, because we have a limited amount of time for the project. Our strategy will be to identify major components of the UI we need feedback (as we are designing them), just like the paper prototype, and try to ask specific questions of the random people we find. </li>
                    <li>This will mostly give us feedback specifically on whether is a component is *simple and intuitive*, but will not give us feedback on whether higher level ideas components like “automatically splitting bills evenly” is useful or will be used a lot. </li>
                    <li>This will be done while developing. We plan to develop the product in a sequential way--implement the high level features one at a time together. Then, when a use case is completely finished (or at least the UI portion), we will try to grab people to try the system to see if it is usable. </li>
                  </ul>
                  </li>
                  <li><h4>Bug Tracking</h4>
                    <p>We will be using GitHub’s issue tracker, any issue not merged yet will be dealt with in pull request but any bug found after merging will be posted on the tracker. We will essentially follow the guidelines from class today and Joel’s blog--find bugs early (testing), fix bugs early (don’t forget about them), and formally keep track of bugs (GitHub). </p>
                  </li>
                </ul>

              <hr>

              <h2 id="codingStyle">Coding Style Guidelines</h2>
              <p>Here are our guidelines for using HTML/CSS, AngularJS/JavaScript, and Ruby On Rails:</p>
                <ul>
                 <li><b>HTML/CSS</b><br>
                  We will be using the <a href="https://google-styleguide.googlecode.com/svn/trunk/htmlcssguide.xml">google HTML/CSS guidelines</a> as well as <a href="https://developers.google.com/speed/docs/best-practices/rendering">CSS best-practices</a> to double check our HTML/CSS. For HTML and CSS there are <a href="http://validator.w3.org/">validators</a> that check HTML and CSS. Stylewise there are options like <a href="http://csslint.net/">CSS Lint</a>. And of course code review by other group mates would help check our consistency with the google style guide.
                 </li>
                 <br>
                 <li><b>JavaScript and AngularJS</b><br>
                  We again will be using the <a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml">google style guide</a> for our javascripts. In addition to javascript, we're using AngularJS for many of our features and will be following the <a href="https://google-styleguide.googlecode.com/svn/trunk/angularjs-google-style.html">Angular JS style guide</a>. For a good style checker, <a href="http://www.jslint.com/">JS Lint will help us catch mistakes</a>, as well as code reviews by teammates.
                 </li>
                 <br>
                 <li><b>Ruby on Rails</b><br>
                 Ruby on Rails doesn’t have a style guide from google nor other major source, but there is one from the <a href="https://github.com/bbatsov/ruby-style-guide">Ruby on Rails website</a>. There is also a <a href="https://github.com/bbatsov/rubocop">Ruby static code analyzer</a>to help us because our team is unfamiliar with Ruby. Code review here will be helpful because while we check the code, we'll also be learning the language.
                 </li>

              <hr>
              <h2 id="changeLogSRS">Change Log</h2>







                </ul>
      		</div> 
  	</div>
</div>



        
        <script type='text/javascript' src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>


        <script type='text/javascript' src="//netdna.bootstrapcdn.com/bootstrap/3.0.3/js/bootstrap.min.js"></script>





        
        <!-- JavaScript jQuery code from Bootply.com editor -->
        
        <script type='text/javascript'>
        
        $(document).ready(function() {
        
            

        
        });
        
        </script>
        
    </body>
</html>